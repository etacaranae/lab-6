/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab6;
import java.util.*;
import java.io.*;

public class Components {
    static boolean[][] matrix; // adjacency matrix to represent the graph
    static int[] nodes; // array for use in traversing/flooding the graph to find components

    public static void main(String[] args) throws FileNotFoundException {
        File f = new File(args[0]);

        Scanner s = new Scanner(f);

        createAdjMatrix(s); // create the matrix

        flood(); // mark the components

        System.out.println(countComponents());

        s.close();
    }

    /**
     * given a text file of a graph, create an adjacency matrix for the graph
     * precondition: the scanner is reading a correctly formatted file
     */
    public static void createAdjMatrix(Scanner s) {
        // create a matrix of the appropriate size
        int n = s.nextInt();
        matrix = new boolean[n][n];
        nodes = new int[n];

        // while there are still edges not recorded in the matrix
        while (s.hasNextLine()) {
            // determine the endpoints of the next edge in the graph
            int node1 = s.nextInt();
            int node2 = s.nextInt();

            //fill that edge into the matrix
            matrix[node1][node2] = true;
            matrix[node2][node1] = true;
        }
    }

    /**
     * marks the nodes in connected subgraphs with the same values 
     * precondition: an adjacency matrix has been created
     */
    public static void flood() {
        // for each node in the graph, try to reach and mark all nodes with its node number
        for (int i = 0; i < nodes.length; i++) {
            dfs(i, i);
        }
    }

    /**
     * starting from node node n, traverses the graph and gives each visited node the value v
     */
    public static void dfs(int n, int v) {
        nodes[n] = v; // mark the node as visited

        // visit each node it is possible to visit
        for (int i = 0; i < matrix[n].length; i++) {
            // a node is possible to visit if there is an edge connecting the two
            // and the other node hasn't been visited yet
            if (matrix[n][i] == true && nodes[i] != v) {
                dfs(i, v);
            }
        }
    }

    /**
     * counts the number of components
     * precondition: the graph has been flooded
     */
    public static int countComponents() {
        int count = 0;
        // check each node to see if it's visitation/flood value equals its index
        // each node will have its value be the index of the last node that could reach it
        // a node can always reach itself
        // so each node in a connected component will have the same value
        // and the value will be different for each component
        // and each component will have exactly 1 node with a value matching its index 
        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == i) {
                count++;
            }
        }
        return count;
    }


}
